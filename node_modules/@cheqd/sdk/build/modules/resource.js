"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ResourceModule = exports.isMsgCreateResourceEncodeObject = exports.typeUrlMsgCreateResourceResponse = exports.typeUrlMsgCreateResource = void 0;
const _1 = require("./_");
const signer_1 = require("../signer");
const tx_1 = require("@cheqd/ts-proto/resource/v1/tx");
const protobufjs_1 = require("protobufjs");
exports.typeUrlMsgCreateResource = `/${tx_1.protobufPackage}.MsgCreateResource`;
exports.typeUrlMsgCreateResourceResponse = `/${tx_1.protobufPackage}.MsgCreateResourceResponse`;
function isMsgCreateResourceEncodeObject(obj) {
    return obj.typeUrl === exports.typeUrlMsgCreateResource;
}
exports.isMsgCreateResourceEncodeObject = isMsgCreateResourceEncodeObject;
class ResourceModule extends _1.AbstractCheqdSDKModule {
    constructor(signer) {
        super(signer);
        this.methods = {
            createResourceTx: this.createResourceTx.bind(this)
        };
    }
    getRegistryTypes() {
        return [];
    }
    // We need this workagound because amino encoding is used in cheqd-node to derive sign bytes for identity messages.
    // In most cases it works the same way as protobuf encoding, but in the MsgCreateResourcePayload
    // we use non-default property indexes so we need this separate encoding function.
    // TODO: Remove this workaround when cheqd-node will use protobuf encoding.
    static getMsgCreateResourcePayloadAminoSignBytes(message) {
        const writer = new protobufjs_1.Writer();
        if (message.collectionId !== "") {
            writer.uint32(10).string(message.collectionId);
        }
        if (message.id !== "") {
            writer.uint32(18).string(message.id);
        }
        if (message.name !== "") {
            writer.uint32(26).string(message.name);
        }
        if (message.resourceType !== "") {
            writer.uint32(34).string(message.resourceType);
        }
        if (message.data.length !== 0) {
            // Animo coded assigns index 5 to this property. In proto definitions it's 6.
            // Since we use amino on node + non default property indexing, we need to encode it manually.
            writer.uint32(42).bytes(message.data);
        }
        return writer.finish();
    }
    static async signPayload(payload, signInputs) {
        const signBytes = ResourceModule.getMsgCreateResourcePayloadAminoSignBytes(payload);
        const signatures = await signer_1.CheqdSigningStargateClient.signIdentityTx(signBytes, signInputs);
        return {
            payload,
            signatures
        };
    }
    async createResourceTx(signInputs, resourcePayload, address, fee, memo, context) {
        if (!this._signer) {
            this._signer = context.sdk.signer;
        }
        const payload = tx_1.MsgCreateResourcePayload.fromPartial(resourcePayload);
        const msg = await ResourceModule.signPayload(payload, signInputs);
        const encObj = {
            typeUrl: exports.typeUrlMsgCreateResource,
            value: msg
        };
        return this._signer.signAndBroadcast(address, [encObj], fee, memo);
    }
}
exports.ResourceModule = ResourceModule;
ResourceModule.registryTypes = [
    [exports.typeUrlMsgCreateResource, tx_1.MsgCreateResource],
    [exports.typeUrlMsgCreateResourceResponse, tx_1.MsgCreateResourceResponse]
];
//# sourceMappingURL=resource.js.map