"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createSignInputsFromKeyPair = exports.convertKeyPairtoTImportableEd25519Key = exports.createDidPayloadWithSignInputs = exports.createDidPayload = exports.createDidVerificationMethod = exports.createVerificationKeys = exports.createKeyPairHex = exports.createKeyPairBase64 = exports.createKeyPairRaw = exports.createSignInputsFromImportableEd25519Key = exports.isEqualKeyValuePair = exports.parseToKeyValuePair = void 0;
const types_1 = require("./types");
const uint8arrays_1 = require("uint8arrays");
const basics_1 = require("multiformats/basics");
const did_jwt_1 = require("did-jwt");
const ed25519_1 = require("@stablelib/ed25519");
const uuid_1 = require("uuid");
const tx_1 = require("@cheqd/ts-proto/cheqd/v1/tx");
function parseToKeyValuePair(object) {
    return Object.entries(object).map(([key, value]) => ({ key, value }));
}
exports.parseToKeyValuePair = parseToKeyValuePair;
function isEqualKeyValuePair(kv1, kv2) {
    return kv1.every((item, index) => item.key === kv2[index].key && item.value === kv2[index].value);
}
exports.isEqualKeyValuePair = isEqualKeyValuePair;
function createSignInputsFromImportableEd25519Key(key, verificationMethod) {
    if ((verificationMethod === null || verificationMethod === void 0 ? void 0 : verificationMethod.length) === 0)
        throw new Error('No verification methods provided');
    const publicKey = (0, uint8arrays_1.fromString)(key.publicKeyHex, 'hex');
    for (const method of verificationMethod) {
        switch (method === null || method === void 0 ? void 0 : method.type) {
            case types_1.VerificationMethods.Base58:
                const publicKeyMultibase = basics_1.bases['base58btc'].encode(publicKey);
                if (method.publicKeyMultibase === publicKeyMultibase) {
                    return {
                        verificationMethodId: method.id,
                        privateKeyHex: key.privateKeyHex
                    };
                }
            case types_1.VerificationMethods.JWK:
                const publicKeyJWK = parseToKeyValuePair({
                    crv: 'Ed25519',
                    kty: 'OKP',
                    x: (0, uint8arrays_1.toString)(publicKey, 'base64url')
                });
                if (isEqualKeyValuePair(method.publicKeyJwk, publicKeyJWK)) {
                    return {
                        verificationMethodId: method.id,
                        privateKeyHex: key.privateKeyHex
                    };
                }
        }
    }
    throw new Error('No verification method type provided');
}
exports.createSignInputsFromImportableEd25519Key = createSignInputsFromImportableEd25519Key;
function createKeyPairRaw(seed) {
    return seed ? (0, ed25519_1.generateKeyPairFromSeed)((0, uint8arrays_1.fromString)(seed)) : (0, ed25519_1.generateKeyPair)();
}
exports.createKeyPairRaw = createKeyPairRaw;
function createKeyPairBase64(seed) {
    const keyPair = seed ? (0, ed25519_1.generateKeyPairFromSeed)((0, uint8arrays_1.fromString)(seed)) : (0, ed25519_1.generateKeyPair)();
    return {
        publicKey: (0, uint8arrays_1.toString)(keyPair.publicKey, 'base64'),
        privateKey: (0, uint8arrays_1.toString)(keyPair.secretKey, 'base64'),
    };
}
exports.createKeyPairBase64 = createKeyPairBase64;
function createKeyPairHex(seed) {
    const keyPair = createKeyPairRaw(seed);
    return {
        publicKey: (0, uint8arrays_1.toString)(keyPair.publicKey, 'hex'),
        privateKey: (0, uint8arrays_1.toString)(keyPair.secretKey, 'hex'),
    };
}
exports.createKeyPairHex = createKeyPairHex;
function createVerificationKeys(keyPair, algo, key, length = 32, network = types_1.CheqdNetwork.Testnet) {
    let methodSpecificId;
    let didUrl;
    switch (algo) {
        case types_1.MethodSpecificIdAlgo.Base58:
            methodSpecificId = basics_1.bases['base58btc'].encode((0, did_jwt_1.base64ToBytes)(keyPair.publicKey));
            didUrl = `did:cheqd:${network}:${methodSpecificId.substring(0, length)}`;
            return {
                methodSpecificId,
                didUrl,
                keyId: `${didUrl}#${key}`,
                publicKey: keyPair.publicKey,
            };
        case types_1.MethodSpecificIdAlgo.Uuid:
            methodSpecificId = basics_1.bases['base58btc'].encode((0, did_jwt_1.base64ToBytes)(keyPair.publicKey));
            didUrl = `did:cheqd:${network}:${(0, uuid_1.v4)()}`;
            return {
                methodSpecificId,
                didUrl,
                keyId: `${didUrl}#${key}`,
                publicKey: keyPair.publicKey,
            };
    }
}
exports.createVerificationKeys = createVerificationKeys;
function createDidVerificationMethod(verificationMethodTypes, verificationKeys) {
    var _a;
    return (_a = verificationMethodTypes.map((type, _) => {
        switch (type) {
            case types_1.VerificationMethods.Base58:
                return {
                    id: verificationKeys[_].keyId,
                    type: type,
                    controller: verificationKeys[_].didUrl,
                    publicKeyMultibase: verificationKeys[_].methodSpecificId,
                    publicKeyJwk: []
                };
            case types_1.VerificationMethods.JWK:
                return {
                    id: verificationKeys[_].keyId,
                    type: type,
                    controller: verificationKeys[_].didUrl,
                    publicKeyJwk: parseToKeyValuePair({
                        crv: 'Ed25519',
                        kty: 'OKP',
                        x: (0, uint8arrays_1.toString)((0, uint8arrays_1.fromString)(verificationKeys[_].publicKey, 'base64pad'), 'base64url')
                    }),
                    publicKeyMultibase: ''
                };
        }
    })) !== null && _a !== void 0 ? _a : [];
}
exports.createDidVerificationMethod = createDidVerificationMethod;
function createDidPayload(verificationMethods, verificationKeys) {
    if (!verificationMethods || verificationMethods.length === 0)
        throw new Error('No verification methods provided');
    if (!verificationKeys || verificationKeys.length === 0)
        throw new Error('No verification keys provided');
    const did = verificationKeys[0].didUrl;
    return tx_1.MsgCreateDidPayload.fromPartial({
        id: did,
        controller: verificationKeys.map(key => key.didUrl),
        verificationMethod: verificationMethods,
        authentication: verificationKeys.map(key => key.keyId)
    });
}
exports.createDidPayload = createDidPayload;
function createDidPayloadWithSignInputs(seed, keys) {
    if (seed && keys)
        throw new Error('Only one of seed or keys should be passed as an argument');
    if (!keys) {
        keys = [seed ? createKeyPairBase64(seed) : createKeyPairBase64()];
    }
    const verificationMethodTypes = keys.map((key) => !key.algo || key.algo == types_1.MethodSpecificIdAlgo.Base58 ? types_1.VerificationMethods.Base58 : types_1.VerificationMethods.JWK);
    const verificationKeys = keys.map((key, i) => createVerificationKeys(key, key.algo || types_1.MethodSpecificIdAlgo.Base58, `key-${i}`));
    const verificationMethod = createDidVerificationMethod(verificationMethodTypes, verificationKeys);
    let payload = {
        id: verificationKeys[0].didUrl,
        controller: verificationKeys.map(key => key.didUrl),
        verificationMethod: verificationMethod,
        authentication: verificationKeys.map(key => key.keyId),
    };
    const keyHexs = keys.map((key) => convertKeyPairtoTImportableEd25519Key(key));
    const signInputs = keyHexs.map((key) => createSignInputsFromImportableEd25519Key(key, verificationMethod));
    return { didPayload: tx_1.MsgCreateDidPayload.fromPartial(payload), keys, signInputs };
}
exports.createDidPayloadWithSignInputs = createDidPayloadWithSignInputs;
function convertKeyPairtoTImportableEd25519Key(keyPair) {
    return {
        type: 'Ed25519',
        privateKeyHex: (0, uint8arrays_1.toString)((0, uint8arrays_1.fromString)(keyPair.privateKey, 'base64'), 'hex'),
        kid: 'kid',
        publicKeyHex: (0, uint8arrays_1.toString)((0, uint8arrays_1.fromString)(keyPair.publicKey, 'base64'), 'hex')
    };
}
exports.convertKeyPairtoTImportableEd25519Key = convertKeyPairtoTImportableEd25519Key;
function createSignInputsFromKeyPair(didDocument, keys) {
    const keyHexs = keys.map((key) => convertKeyPairtoTImportableEd25519Key(key));
    const signInputs = keyHexs.map((key) => createSignInputsFromImportableEd25519Key(key, didDocument.verificationMethod));
    return signInputs;
}
exports.createSignInputsFromKeyPair = createSignInputsFromKeyPair;
//# sourceMappingURL=utils.js.map