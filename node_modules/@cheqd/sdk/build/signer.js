"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CheqdSigningStargateClient = exports.makeDidAuthInfoBytes = exports.makeSignerInfos = exports.calculateDidFee = void 0;
const proto_signing_1 = require("@cosmjs/proto-signing");
const stargate_1 = require("@cosmjs/stargate");
const tendermint_rpc_1 = require("@cosmjs/tendermint-rpc");
const registry_1 = require("./registry");
const tx_1 = require("@cheqd/ts-proto/cheqd/v1/tx");
const types_1 = require("./types");
const did_jwt_1 = require("did-jwt");
const uint8arrays_1 = require("uint8arrays");
const utils_1 = require("@cosmjs/utils");
const amino_1 = require("@cosmjs/amino");
const math_1 = require("@cosmjs/math");
const encoding_1 = require("@cosmjs/encoding");
const tx_2 = require("cosmjs-types/cosmos/tx/v1beta1/tx");
const signing_1 = require("cosmjs-types/cosmos/tx/signing/v1beta1/signing");
const long_1 = __importDefault(require("long"));
function calculateDidFee(gasLimit, gasPrice) {
    return (0, stargate_1.calculateFee)(gasLimit, gasPrice);
}
exports.calculateDidFee = calculateDidFee;
function makeSignerInfos(signers, signMode) {
    return signers.map(({ pubkey, sequence }) => ({
        publicKey: pubkey,
        modeInfo: {
            single: { mode: signMode },
        },
        sequence: long_1.default.fromNumber(sequence),
    }));
}
exports.makeSignerInfos = makeSignerInfos;
function makeDidAuthInfoBytes(signers, feeAmount, gasLimit, feePayer, signMode = signing_1.SignMode.SIGN_MODE_DIRECT) {
    const authInfo = {
        signerInfos: makeSignerInfos(signers, signMode),
        fee: {
            amount: [...feeAmount],
            gasLimit: long_1.default.fromNumber(gasLimit),
            payer: feePayer
        }
    };
    //* There is a `Long` type incompatibility in the protobuf library that causes the following line to throw an error. No actual type mismatch is ever encountered.
    // @ts-ignore
    return tx_2.AuthInfo.encode(tx_2.AuthInfo.fromPartial(authInfo)).finish();
}
exports.makeDidAuthInfoBytes = makeDidAuthInfoBytes;
class CheqdSigningStargateClient extends stargate_1.SigningStargateClient {
    static async connectWithSigner(endpoint, signer, options) {
        const tmClient = await tendermint_rpc_1.Tendermint34Client.connect(endpoint);
        return new CheqdSigningStargateClient(tmClient, signer, {
            registry: (options === null || options === void 0 ? void 0 : options.registry) ? options.registry : (0, registry_1.createDefaultCheqdRegistry)(),
            ...options
        });
    }
    constructor(tmClient, signer, options = {}) {
        super(tmClient, signer, options);
        this.didSigners = {};
        this._signer = signer;
        if (options.gasPrice)
            this._gasPrice = options.gasPrice;
        /** GRPC Connection */
        /* if (tmClient) {
            this.cheqdExtensions = QueryClient.withExtensions(tmClient, setupCheqdExtensions)
        } */
    }
    async signAndBroadcast(signerAddress, messages, fee, memo = "") {
        let usedFee;
        if (fee == "auto" || typeof fee === "number") {
            (0, utils_1.assertDefined)(this._gasPrice, "Gas price must be set in the client options when auto gas is used.");
            const gasEstimation = await this.simulate(signerAddress, messages, memo);
            const multiplier = typeof fee === "number" ? fee : 1.3;
            usedFee = calculateDidFee(Math.round(gasEstimation * multiplier), this._gasPrice);
            usedFee.payer = signerAddress;
        }
        else {
            usedFee = fee;
            (0, utils_1.assertDefined)(usedFee.payer, "Payer address must be set when fee is not auto.");
            signerAddress = usedFee.payer;
        }
        const txRaw = await this.sign(signerAddress, messages, usedFee, memo);
        const txBytes = tx_2.TxRaw.encode(txRaw).finish();
        return this.broadcastTx(txBytes, this.broadcastTimeoutMs, this.broadcastPollIntervalMs);
    }
    async sign(signerAddress, messages, fee, memo, explicitSignerData) {
        let signerData;
        if (explicitSignerData) {
            signerData = explicitSignerData;
        }
        else {
            const { accountNumber, sequence } = await this.getSequence(signerAddress);
            const chainId = await this.getChainId();
            signerData = {
                accountNumber: accountNumber,
                sequence: sequence,
                chainId: chainId,
            };
        }
        return this._signDirect(signerAddress, messages, fee, memo, signerData);
        // TODO: override signAmino as well
        /* return isOfflineDirectSigner(this._signer)
            ? this._signDirect(signerAddress, messages, fee, memo, signerData)
            : this._signAmino(signerAddress, messages, fee, memo, signerData) */
    }
    async _signDirect(signerAddress, messages, fee, memo, { accountNumber, sequence, chainId }) {
        (0, utils_1.assert)((0, proto_signing_1.isOfflineDirectSigner)(this._signer));
        const accountFromSigner = (await this._signer.getAccounts()).find((account) => account.address === signerAddress);
        if (!accountFromSigner) {
            throw new Error("Failed to retrieve account from signer");
        }
        const pubkey = (0, proto_signing_1.encodePubkey)((0, amino_1.encodeSecp256k1Pubkey)(accountFromSigner.pubkey));
        const txBodyEncodeObject = {
            typeUrl: "/cosmos.tx.v1beta1.TxBody",
            value: {
                messages: messages,
                memo: memo,
            },
        };
        const txBodyBytes = this.registry.encode(txBodyEncodeObject);
        const gasLimit = math_1.Int53.fromString(fee.gas).toNumber();
        const authInfoBytes = makeDidAuthInfoBytes([{ pubkey, sequence }], fee.amount, gasLimit, fee.payer);
        const signDoc = (0, proto_signing_1.makeSignDoc)(txBodyBytes, authInfoBytes, chainId, accountNumber);
        const { signature, signed } = await this._signer.signDirect(signerAddress, signDoc);
        return tx_2.TxRaw.fromPartial({
            bodyBytes: signed.bodyBytes,
            authInfoBytes: signed.authInfoBytes,
            signatures: [(0, encoding_1.fromBase64)(signature.signature)],
        });
    }
    async checkDidSigners(verificationMethods = []) {
        if (verificationMethods.length === 0) {
            throw new Error('No verification methods provided');
        }
        verificationMethods.forEach((verificationMethod) => {
            var _a, _b, _c;
            if (!Object.values(types_1.VerificationMethods).includes((_a = verificationMethod.type) !== null && _a !== void 0 ? _a : '')) {
                throw new Error(`Unsupported verification method type: ${verificationMethod.type}`);
            }
            if (!this.didSigners[(_b = verificationMethod.type) !== null && _b !== void 0 ? _b : '']) {
                this.didSigners[(_c = verificationMethod.type) !== null && _c !== void 0 ? _c : ''] = did_jwt_1.EdDSASigner;
            }
        });
        return this.didSigners;
    }
    async getDidSigner(verificationMethodId, verificationMethods) {
        var _a;
        await this.checkDidSigners(verificationMethods);
        const verificationMethod = (_a = verificationMethods.find(method => method.id === verificationMethodId)) === null || _a === void 0 ? void 0 : _a.type;
        if (!verificationMethod) {
            throw new Error(`Verification method for ${verificationMethodId} not found`);
        }
        return this.didSigners[verificationMethod];
    }
    async signCreateDidTx(signInputs, payload) {
        await this.checkDidSigners(payload === null || payload === void 0 ? void 0 : payload.verificationMethod);
        const signBytes = tx_1.MsgCreateDidPayload.encode(payload).finish();
        const signInfos = await Promise.all(signInputs.map(async (signInput) => {
            return {
                verificationMethodId: signInput.verificationMethodId,
                // TODO: We can't rely on `payload.verificationMethod` here because `CreateResourceTx` doesn't have it
                signature: (0, uint8arrays_1.toString)((0, did_jwt_1.base64ToBytes)((await (await this.getDidSigner(signInput.verificationMethodId, payload.verificationMethod))((0, did_jwt_1.hexToBytes)(signInput.privateKeyHex))(signBytes))), 'base64pad')
            };
        }));
        return signInfos;
    }
    async signUpdateDidTx(signInputs, payload) {
        await this.checkDidSigners(payload === null || payload === void 0 ? void 0 : payload.verificationMethod);
        const signBytes = tx_1.MsgUpdateDidPayload.encode(payload).finish();
        const signInfos = await Promise.all(signInputs.map(async (signInput) => {
            return {
                verificationMethodId: signInput.verificationMethodId,
                // TODO: We can't rely on `payload.verificationMethod` here because `CreateResourceTx` doesn't have it
                signature: (0, uint8arrays_1.toString)((0, did_jwt_1.base64ToBytes)((await (await this.getDidSigner(signInput.verificationMethodId, payload.verificationMethod))((0, did_jwt_1.hexToBytes)(signInput.privateKeyHex))(signBytes))), 'base64pad')
            };
        }));
        return signInfos;
    }
    static async signIdentityTx(signBytes, signInputs) {
        let signInfos = [];
        for (let signInput of signInputs) {
            if (typeof (signInput.keyType) === undefined) {
                throw new Error('Key type is not defined');
            }
            let signature;
            switch (signInput.keyType) {
                case 'Ed25519':
                    signature = (await (0, did_jwt_1.EdDSASigner)((0, did_jwt_1.hexToBytes)(signInput.privateKeyHex))(signBytes));
                    break;
                case 'Secp256k1':
                    signature = (await (0, did_jwt_1.ES256KSigner)((0, did_jwt_1.hexToBytes)(signInput.privateKeyHex))(signBytes));
                    break;
                case 'P256':
                    signature = (await (0, did_jwt_1.ES256Signer)((0, did_jwt_1.hexToBytes)(signInput.privateKeyHex))(signBytes));
                    break;
                default:
                    throw new Error(`Unsupported signature type: ${signInput.keyType}`);
            }
            signInfos.push({
                verificationMethodId: signInput.verificationMethodId,
                signature: (0, uint8arrays_1.toString)((0, did_jwt_1.base64ToBytes)(signature), 'base64pad')
            });
        }
        return signInfos;
    }
}
exports.CheqdSigningStargateClient = CheqdSigningStargateClient;
//# sourceMappingURL=signer.js.map